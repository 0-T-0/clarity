"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var core_1 = require("@angular/core");
var rxjs_1 = require("rxjs");
var custom_filter_1 = require("../../providers/custom-filter");
var datagrid_filter_1 = require("../../datagrid-filter");
var DatagridStringFilter = (function () {
    function DatagridStringFilter(renderer, _cdr) {
        this.renderer = renderer;
        this._cdr = _cdr;
        /**
         * Indicates if the filter dropdown is open
         */
        this.open = false;
        /**
         * The Observable required as part of the Filter interface
         */
        this._changes = new rxjs_1.Subject();
        /**
         * Raw input value
         */
        this._rawValue = "";
        /**
         * Input value converted to lowercase
         */
        this._lowerCaseValue = "";
    }
    DatagridStringFilter.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.filterContainer.filter = this;
        this.filterContainer.openChanged.subscribe(function (open) {
            if (open) {
                // We need the timeout because at the time this executes, the input isn't
                // displayed yet.
                setTimeout(function () {
                    _this.renderer.invokeElementMethod(_this.input.nativeElement, "focus");
                });
            }
        });
    };
    Object.defineProperty(DatagridStringFilter.prototype, "changes", {
        // We do not want to expose the Subject itself, but the Observable which is read-only
        get: function () {
            return this._changes.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(DatagridStringFilter.prototype, "value", {
        get: function () {
            return this._rawValue;
        },
        /**
         * Common setter for the input value
         */
        set: function (value) {
            this._rawValue = value;
            this._lowerCaseValue = value.toLowerCase().trim();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridStringFilter.prototype, "lowerCaseValue", {
        get: function () {
            return this._lowerCaseValue;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Indicates if the filter is currently active, meaning the input is not empty
     */
    DatagridStringFilter.prototype.isActive = function () {
        return !!this.value;
    };
    /**
     * Tests if an item matches a search text
     */
    DatagridStringFilter.prototype.accepts = function (item) {
        // We always test with the lowercase value of the input, to stay case insensitive
        return this.filter.accepts(item, this.lowerCaseValue);
    };
    ;
    /**
     * Closes the container and applies the filter
     */
    DatagridStringFilter.prototype.closeContainer = function () {
        this.open = false;
        this._changes.next(this.value);
    };
    __decorate([
        core_1.Input("clrDgStringFilter"), 
        __metadata('design:type', Object)
    ], DatagridStringFilter.prototype, "filter", void 0);
    __decorate([
        core_1.ViewChild("input"), 
        __metadata('design:type', core_1.ElementRef)
    ], DatagridStringFilter.prototype, "input", void 0);
    __decorate([
        core_1.ViewChild(datagrid_filter_1.DatagridFilter), 
        __metadata('design:type', datagrid_filter_1.DatagridFilter)
    ], DatagridStringFilter.prototype, "filterContainer", void 0);
    DatagridStringFilter = __decorate([
        core_1.Component({
            selector: "clr-dg-string-filter",
            providers: [{ provide: custom_filter_1.CustomFilter, useExisting: DatagridStringFilter }],
            template: "\n        <clr-dg-filter [(clrDgFilterOpen)]=\"open\">\n            <!-- \n                Even though this *ngIf looks useless because the filter container already has one,\n                it prevents NgControlStatus and other directives automatically added by Angular \n                on inputs with NgModel from freaking out because of their host binding changing\n                mid-change detection when the input is destroyed.\n            -->\n            <form (submit)=\"closeContainer()\" *ngIf=\"open\">\n                <input #input type=\"text\" name=\"search\" [(ngModel)]=\"value\" />\n                <div>\n                    <button type=\"submit\" class=\"btn btn-primary btn-sm datagrid-filter-apply\">\n                        Filter\n                    </button>\n                </div>\n            </form>\n        </clr-dg-filter>\n    "
        }), 
        __metadata('design:paramtypes', [core_1.Renderer, core_1.ChangeDetectorRef])
    ], DatagridStringFilter);
    return DatagridStringFilter;
}());
exports.DatagridStringFilter = DatagridStringFilter;
